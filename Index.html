<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ナンバープレート自動マスク（ブラウザ）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "メイリオ", sans-serif; padding:16px; max-width:980px; margin:auto;}
    h1{font-size:1.3rem}
    #controls{display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px}
    canvas{border:1px solid #ccc; max-width:100%;}
    .btn{padding:8px 12px; border-radius:6px; border:1px solid #888; background:#f6f6f6; cursor:pointer}
    .btn.primary{background:#1e90ff;color:white;border-color:#0b66c2}
    #params{margin-top:8px;font-size:0.9rem}
    .info{margin-top:8px;color:#444}
    #manualMask{margin-top:8px}
  </style>
</head>
<body>
  <h1>ナンバープレートを認識して白塗りする（ブラウザ版）</h1>

  <div id="controls">
    <input id="file" type="file" accept="image/*" />
    <button id="detectBtn" class="btn primary">検出して塗りつぶす</button>
    <button id="downloadBtn" class="btn">ダウンロード</button>
    <button id="clearBtn" class="btn">クリア</button>
  </div>

  <div id="params">
    <label>最小候補面積（px）: <input id="minArea" type="number" value="2000" style="width:90px"></label>
    <label style="margin-left:12px">輪郭近似のε: <input id="eps" type="number" value="0.02" step="0.01" style="width:70px"></label>
    <label style="margin-left:12px">OCRチェック（簡易）: <input id="useOCR" type="checkbox" checked></label>
  </div>

  <p class="info">※精度向上は撮影時にナンバーを正面に近づける・解像度を上げる・反射を避けること。検出失敗時は手動で矩形を調整できます。</p>

  <canvas id="canvas"></canvas>

  <div id="manualMask">
    <p>手動操作：選択した白い矩形をドラッグで移動、角をドラッグでリサイズできます。矩形を右クリックで削除。</p>
  </div>

  <!-- OpenCV.js CDN -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <!-- Tesseract.js CDN（OCRオプション） -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>

  <script>
  // Wait for OpenCV.js to be ready
  let cvReady = false;
  let cvInterval = setInterval(()=>{
    if (window.cv && cv && cv.Mat) {
      clearInterval(cvInterval);
      cvReady = true;
      console.log('OpenCV.js ready');
    }
  }, 200);

  const fileInput = document.getElementById('file');
  const detectBtn = document.getElementById('detectBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const clearBtn = document.getElementById('clearBtn');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const minAreaInput = document.getElementById('minArea');
  const epsInput = document.getElementById('eps');
  const useOCR = document.getElementById('useOCR');

  let img = new Image();
  let currentRects = []; // [{x,y,w,h}]
  let dragging = null;
  let dragOffset = {x:0,y:0};
  let dragCorner = null;

  fileInput.addEventListener('change', e=>{
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    img.onload = () => {
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      ctx.drawImage(img,0,0);
      currentRects = [];
      draw();
      URL.revokeObjectURL(url);
    }
    img.src = url;
  });

  detectBtn.addEventListener('click', async ()=>{
    if (!img.src) return alert('画像を選択してください');
    if (!cvReady) return alert('OpenCV.js が読み込まれるのを待ってください（少し時間がかかることがあります）');

    // prepare mats
    const src = cv.imread(img);
    const orig = src.clone();
    // resize if too large for performance
    const MAX = 1600;
    if (src.cols > MAX) {
      let ratio = MAX / src.cols;
      cv.resize(src, src, new cv.Size(0,0), ratio, ratio, cv.INTER_AREA);
    }

    try {
      // convert to gray, blur, edge
      let gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.bilateralFilter(gray, gray, 9, 75, 75);
      let edged = new cv.Mat();
      cv.Canny(gray, edged, 75, 200);

      // find contours
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

      // iterate contours and look for rectangle-like shapes
      const candidates = [];
      for (let i=0;i<contours.size();i++){
        let cnt = contours.get(i);
        let peri = cv.arcLength(cnt, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, epsInput.value * peri, true);
        if (approx.rows === 4) {
          // bounding rect
          let rect = cv.boundingRect(approx);
          let area = rect.width * rect.height;
          if (area < Number(minAreaInput.value)) { approx.delete(); cnt.delete(); continue; }
          // aspect ratio filter: plates are wide rectangles; allow some range
          let ar = rect.width / rect.height;
          if (ar < 2.0 || ar > 8.0) { approx.delete(); cnt.delete(); continue; }
          candidates.push(rect);
        }
        approx.delete(); cnt.delete();
      }

      // Optionally run OCR to confirm (simple heuristics)
      let confirmed = [];
      if (candidates.length > 0 && useOCR.checked && window.Tesseract) {
        for (let r of candidates) {
          // crop candidate from original full-resolution image for better OCR
          let cropCanvas = document.createElement('canvas');
          let scaleX = img.naturalWidth / src.cols;
          let scaleY = img.naturalHeight / src.rows;
          cropCanvas.width = Math.round(r.width * scaleX);
          cropCanvas.height = Math.round(r.height * scaleY);
          let cc = cropCanvas.getContext('2d');
          cc.drawImage(img, r.x * scaleX, r.y * scaleY, r.width * scaleX, r.height * scaleY, 0,0,cropCanvas.width,cropCanvas.height);
          // run OCR (digits/letters check)
          try {
            let { data } = await Tesseract.recognize(cropCanvas, 'jpn+eng', { logger: m => {} });
            let text = (data && data.text) ? data.text.replace(/\s+/g,'') : '';
            // heuristics: license plate contains digits; check presence of at least 2 digits
            let digits = (text.match(/\d/g) || []).length;
            if (digits >= 2) {
              confirmed.push({x: Math.round(r.x * scaleX), y: Math.round(r.y * scaleY), w: Math.round(r.width * scaleX), h: Math.round(r.height * scaleY)});
            }
          } catch (err) {
            console.warn('OCR failed', err);
          }
        }
      } else {
        // no OCR: scale candidate rects to original image coordinates
        let scaleX = img.naturalWidth / src.cols;
        let scaleY = img.naturalHeight / src.rows;
        for (let r of candidates) {
          confirmed.push({x: Math.round(r.x*scaleX), y: Math.round(r.y*scaleY), w: Math.round(r.width*scaleX), h: Math.round(r.height*scaleY)});
        }
      }

      // if nothing confirmed and candidates existed, fallback to top candidate(s)
      if (confirmed.length === 0 && candidates.length > 0) {
        let scaleX = img.naturalWidth / src.cols;
        let scaleY = img.naturalHeight / src.rows;
        // choose largest area candidate
        candidates.sort((a,b)=> (b.width*b.height) - (a.width*a.height));
        let r = candidates[0];
        confirmed.push({x: Math.round(r.x*scaleX), y: Math.round(r.y*scaleY), w: Math.round(r.width*scaleX), h: Math.round(r.height*scaleY)});
      }

      // set currentRects and draw white mask rectangles
      currentRects = confirmed;
      draw();

      // cleanup
      gray.delete(); edged.delete(); contours.delete(); hierarchy.delete();
      src.delete(); orig.delete();
      alert('検出完了: ' + currentRects.length + ' 件（手動で調整できます）');
    } catch (err) {
      console.error(err);
      alert('処理中にエラーが発生しました: ' + err.message);
    }
  });

  downloadBtn.addEventListener('click', ()=>{
    if (!img.src) return alert('画像を選択してください');
    // combine image + white masks into final canvas
    draw(true);
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'masked.png';
    a.click();
  });

  clearBtn.addEventListener('click', ()=>{
    if (!img.src) return;
    currentRects = [];
    ctx.drawImage(img,0,0);
  });

  // Drawing routine: if finalRender true, actually paint white rectangles on image
  function draw(finalRender=false){
    if (!img.src) return;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0);
    if (currentRects.length === 0) return;
    ctx.save();
    ctx.lineWidth = 3;
    for (let i=0;i<currentRects.length;i++){
      const r = currentRects[i];
      if (finalRender) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(r.x, r.y, r.w, r.h);
      } else {
        ctx.strokeStyle = 'red';
        ctx.strokeRect(r.x, r.y, r.w, r.h);
        ctx.fillStyle = 'rgba(255,255,255,0.75)';
        ctx.fillRect(r.x, r.y, r.w, r.h);
        // draw handle circles (for manual resize)
        drawHandles(r);
      }
    }
    ctx.restore();
  }

  function drawHandles(r) {
    const hs = 8;
    const corners = [
      {x: r.x, y: r.y},
      {x: r.x + r.w, y: r.y},
      {x: r.x, y: r.y + r.h},
      {x: r.x + r.w, y: r.y + r.h}
    ];
    ctx.fillStyle = '#333';
    corners.forEach(c=> ctx.fillRect(c.x - hs/2, c.y - hs/2, hs, hs));
  }

  // Mouse interactions for manual adjust
  canvas.addEventListener('mousedown', e=>{
    if (!img.src) return;
    const pos = getMousePos(e);
    // check corners first
    for (let i=0;i<currentRects.length;i++){
      const r = currentRects[i];
      const corner = detectCornerHit(r, pos);
      if (corner) { dragging = i; dragCorner = corner; return; }
    }
    // then check inside any rect
    for (let i=currentRects.length-1;i>=0;i--){
      const r = currentRects[i];
      if (pos.x >= r.x && pos.x <= r.x + r.w && pos.y >= r.y && pos.y <= r.y + r.h) {
        dragging = i;
        dragOffset.x = pos.x - r.x;
        dragOffset.y = pos.y - r.y;
        dragCorner = null;
        return;
      }
    }
  });

  canvas.addEventListener('mousemove', e=>{
    if (dragging === null) return;
    const pos = getMousePos(e);
    let r = currentRects[dragging];
    if (!r) return;
    if (dragCorner) {
      // resize based on which corner
      let nx = r.x, ny = r.y, nw = r.w, nh = r.h;
      if (dragCorner === 'tl') {
        nx = pos.x; ny = pos.y;
        nw = (r.x + r.w) - nx; nh = (r.y + r.h) - ny;
      } else if (dragCorner === 'tr') {
        ny = pos.y;
        nw = pos.x - r.x; nh = (r.y + r.h) - ny;
      } else if (dragCorner === 'bl') {
        nx = pos.x;
        nw = (r.x + r.w) - nx; nh = pos.y - r.y;
      } else if (dragCorner === 'br') {
        nw = pos.x - r.x; nh = pos.y - r.y;
      }
      // enforce min size
      if (nw < 10) nw = 10;
      if (nh < 10) nh = 10;
      r.x = Math.round(nx); r.y = Math.round(ny); r.w = Math.round(nw); r.h = Math.round(nh);
    } else {
      // move
      r.x = Math.round(pos.x - dragOffset.x);
      r.y = Math.round(pos.y - dragOffset.y);
    }
    draw();
  });

  canvas.addEventListener('mouseup', e=>{
    dragging = null; dragCorner = null;
  });
  canvas.addEventListener('mouseleave', e=>{
    dragging = null; dragCorner = null;
  });

  canvas.addEventListener('contextmenu', e=>{
    e.preventDefault();
    const pos = getMousePos(e);
    // right click to delete rect under cursor
    for (let i=0;i<currentRects.length;i++){
      const r = currentRects[i];
      if (pos.x >= r.x && pos.x <= r.x + r.w && pos.y >= r.y && pos.y <= r.y + r.h) {
        currentRects.splice(i,1);
        draw();
        return;
      }
    }
  });

  function getMousePos(evt){
    const rect = canvas.getBoundingClientRect();
    return { x: (evt.clientX - rect.left) * (canvas.width / rect.width), y: (evt.clientY - rect.top) * (canvas.height / rect.height) };
  }

  function detectCornerHit(r, pos){
    const hit = 12; // px
    if (Math.abs(pos.x - r.x) < hit && Math.abs(pos.y - r.y) < hit) return 'tl';
    if (Math.abs(pos.x - (r.x+r.w)) < hit && Math.abs(pos.y - r.y) < hit) return 'tr';
    if (Math.abs(pos.x - r.x) < hit && Math.abs(pos.y - (r.y+r.h)) < hit) return 'bl';
    if (Math.abs(pos.x - (r.x+r.w)) < hit && Math.abs(pos.y - (r.y+r.h)) < hit) return 'br';
    return null;
  }
  </script>
</body>
</html>
